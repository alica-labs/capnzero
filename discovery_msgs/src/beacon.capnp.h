// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: beacon.capnp

#ifndef CAPNP_INCLUDED_8c1726f48700b030_
#define CAPNP_INCLUDED_8c1726f48700b030_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

namespace capnp
{
namespace schemas
{

CAPNP_DECLARE_SCHEMA(cd7c0e6550ea3ccc);

} // namespace schemas
} // namespace capnp

namespace discovery_msgs
{

struct Beacon
{
    Beacon() = delete;

    class Reader;
    class Builder;
    class Pipeline;

    struct _capnpPrivate
    {
        CAPNP_DECLARE_STRUCT_HEADER(cd7c0e6550ea3ccc, 1, 2)
#if !CAPNP_LITE
        static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif // !CAPNP_LITE
    };
};

// =======================================================================================

class Beacon::Reader
{
public:
    typedef Beacon Reads;

    Reader() = default;
    inline explicit Reader(::capnp::_::StructReader base)
            : _reader(base)
    {
    }

    inline ::capnp::MessageSize totalSize() const { return _reader.totalSize().asPublic(); }

#if !CAPNP_LITE
    inline ::kj::StringTree toString() const { return ::capnp::_::structString(_reader, *_capnpPrivate::brand()); }
#endif // !CAPNP_LITE

    inline bool hasUuid() const;
    inline ::capnp::Data::Reader getUuid() const;

    inline bool hasIp() const;
    inline ::capnp::Text::Reader getIp() const;

    inline ::int16_t getPort() const;

private:
    ::capnp::_::StructReader _reader;
    template <typename, ::capnp::Kind>
    friend struct ::capnp::ToDynamic_;
    template <typename, ::capnp::Kind>
    friend struct ::capnp::_::PointerHelpers;
    template <typename, ::capnp::Kind>
    friend struct ::capnp::List;
    friend class ::capnp::MessageBuilder;
    friend class ::capnp::Orphanage;
};

class Beacon::Builder
{
public:
    typedef Beacon Builds;

    Builder() = delete; // Deleted to discourage incorrect usage.
                        // You can explicitly initialize to nullptr instead.
    inline Builder(decltype(nullptr)) {}
    inline explicit Builder(::capnp::_::StructBuilder base)
            : _builder(base)
    {
    }
    inline operator Reader() const { return Reader(_builder.asReader()); }
    inline Reader asReader() const { return *this; }

    inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
    inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif // !CAPNP_LITE

    inline bool hasUuid();
    inline ::capnp::Data::Builder getUuid();
    inline void setUuid(::capnp::Data::Reader value);
    inline ::capnp::Data::Builder initUuid(unsigned int size);
    inline void adoptUuid(::capnp::Orphan<::capnp::Data>&& value);
    inline ::capnp::Orphan<::capnp::Data> disownUuid();

    inline bool hasIp();
    inline ::capnp::Text::Builder getIp();
    inline void setIp(::capnp::Text::Reader value);
    inline ::capnp::Text::Builder initIp(unsigned int size);
    inline void adoptIp(::capnp::Orphan<::capnp::Text>&& value);
    inline ::capnp::Orphan<::capnp::Text> disownIp();

    inline ::int16_t getPort();
    inline void setPort(::int16_t value);

private:
    ::capnp::_::StructBuilder _builder;
    template <typename, ::capnp::Kind>
    friend struct ::capnp::ToDynamic_;
    friend class ::capnp::Orphanage;
    template <typename, ::capnp::Kind>
    friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Beacon::Pipeline
{
public:
    typedef Beacon Pipelines;

    inline Pipeline(decltype(nullptr))
            : _typeless(nullptr)
    {
    }
    inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
            : _typeless(kj::mv(typeless))
    {
    }

private:
    ::capnp::AnyPointer::Pipeline _typeless;
    friend class ::capnp::PipelineHook;
    template <typename, ::capnp::Kind>
    friend struct ::capnp::ToDynamic_;
};
#endif // !CAPNP_LITE

// =======================================================================================

inline bool Beacon::Reader::hasUuid() const
{
    return !_reader.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Beacon::Builder::hasUuid()
{
    return !_builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::Data::Reader Beacon::Reader::getUuid() const
{
    return ::capnp::_::PointerHelpers<::capnp::Data>::get(_reader.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline ::capnp::Data::Builder Beacon::Builder::getUuid()
{
    return ::capnp::_::PointerHelpers<::capnp::Data>::get(_builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Beacon::Builder::setUuid(::capnp::Data::Reader value)
{
    ::capnp::_::PointerHelpers<::capnp::Data>::set(_builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline ::capnp::Data::Builder Beacon::Builder::initUuid(unsigned int size)
{
    return ::capnp::_::PointerHelpers<::capnp::Data>::init(_builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Beacon::Builder::adoptUuid(::capnp::Orphan<::capnp::Data>&& value)
{
    ::capnp::_::PointerHelpers<::capnp::Data>::adopt(_builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan<::capnp::Data> Beacon::Builder::disownUuid()
{
    return ::capnp::_::PointerHelpers<::capnp::Data>::disown(_builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Beacon::Reader::hasIp() const
{
    return !_reader.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Beacon::Builder::hasIp()
{
    return !_builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline ::capnp::Text::Reader Beacon::Reader::getIp() const
{
    return ::capnp::_::PointerHelpers<::capnp::Text>::get(_reader.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline ::capnp::Text::Builder Beacon::Builder::getIp()
{
    return ::capnp::_::PointerHelpers<::capnp::Text>::get(_builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Beacon::Builder::setIp(::capnp::Text::Reader value)
{
    ::capnp::_::PointerHelpers<::capnp::Text>::set(_builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline ::capnp::Text::Builder Beacon::Builder::initIp(unsigned int size)
{
    return ::capnp::_::PointerHelpers<::capnp::Text>::init(_builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Beacon::Builder::adoptIp(::capnp::Orphan<::capnp::Text>&& value)
{
    ::capnp::_::PointerHelpers<::capnp::Text>::adopt(_builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan<::capnp::Text> Beacon::Builder::disownIp()
{
    return ::capnp::_::PointerHelpers<::capnp::Text>::disown(_builder.getPointerField(::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline ::int16_t Beacon::Reader::getPort() const
{
    return _reader.getDataField<::int16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline ::int16_t Beacon::Builder::getPort()
{
    return _builder.getDataField<::int16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Beacon::Builder::setPort(::int16_t value)
{
    _builder.setDataField<::int16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

} // namespace discovery_msgs

#endif // CAPNP_INCLUDED_8c1726f48700b030_
